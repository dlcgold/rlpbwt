\documentclass[a4paper,12pt, oneside]{book}

% \usepackage{fullpage}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amstext}
\usepackage{colortbl}
\usepackage{engrec}
\usepackage{rotating}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage[safe,extra]{tipa}
% \usepackage{showkeys}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{microtype}
% \usepackage{fontspec}
\usepackage{enumerate}
\usepackage{braket}
\usepackage{relsize}
\usepackage{marginnote}
\usepackage{pgfplots}
\usepackage{cancel}
\usepackage{polynom}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{pdfpages}
\usepackage{pgfplots}
\usepackage{algorithm}
\usepackage[backend=biber, backref=true, sorting=none]{biblatex}
\usepackage{fvextra}
\usepackage{csquotes}
% \usepackage{natbib}
% \usepackage{algpseudocode}
% \usepackage[cache=false]{minted}
\usepackage{mathtools}
\usepackage[noend]{algpseudocode}
\usepackage{svg}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{blindtext}
\usepackage{titleps}
\addbibresource{thesis.bib}
\usepackage{tikz}\usetikzlibrary{er}\tikzset{multi  attribute /.style={attribute
    ,double  distance =1.5pt}}\tikzset{derived  attribute /.style={attribute
    ,dashed}}\tikzset{total /.style={double  distance =1.5pt}}\tikzset{every
  entity /.style={draw=orange , fill=orange!20}}\tikzset{every  attribute
  /.style={draw=MediumPurple1, fill=MediumPurple1!20}}\tikzset{every
  relationship /.style={draw=Chartreuse2,
    fill=Chartreuse2!20}}\newcommand{\key}[1]{\underline{#1}}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{arrows,shapes,backgrounds,petri} 
\usetikzlibrary{automata,positioning}
\usetikzlibrary{matrix}
% \renewcommand{\chaptermark}[1]{\markboth{#1}{}}
\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead[LO,RE]{\slshape \leftmark}
% \fancyhead[CO,CE]{\slshape\rightmark}
\fancyhead[LE,RO]{\slshape\rightmark}
\fancyfoot[C]{\thepage}
% \fancyhf{}
% \fancyhead[LO,RE]{\slshape \leftmark}
% % \fancyhead[CO,CE]{\slshape\rightmark}
% \fancyhead[LE,RO]{\slshape\thepage}
% \renewcommand{\footrulewidth}{0pt}
% \fancyfoot[C]{\thepage}
% \title{Relazione}
% \fancypagestyle{plain}{% \fancyhf{} % clear all header and footer fields
% \fancyhead[RO,RE]{\thepage}%RO=right odd, RE=right even
% \renewcommand{\headrulewidth}{0pt}
% \renewcommand{\footrulewidth}{0.3pt}}


\pgfplotsset{compat=1.13}

\begin{document}
\restoregeometry
\definecolor{shadecolor}{gray}{0.80}
\setlist{leftmargin = 2cm}
\newtheorem{teorema}{Teorema}
\newtheorem{definizione}{Definizione}
\newtheorem{esempio}{Esempio}
\newtheorem{corollario}{Corollario}
\newtheorem{lemma}{Lemma}
\newtheorem{osservazione}{Osservazione}
\newtheorem{nota}{Nota}
\newtheorem{esercizio}{Esercizio}

\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}

\renewcommand{\chaptermark}[1]{%
  \markboth{\chaptername
    \ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection.\ #1}}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}

\newcommand{\MYhref}[3][blue]{\href{#2}{\color{#1}{#3}}}%
\newcommand{\hiddenchapter}[1]{
  \stepcounter{chapter*}
  \chapter*{\arabic{chapter}\hspace{1em}{#1}}
}
% \pagenumbering{roman}

\newpage
\subsection*{RLPBWT con bitvectors}

\begin{algorithm}[H]
  \scriptsize
  \begin{algorithmic}[1]
    \Function{build}{$col,\,\, pref,\,\, div$}
    \State $c\gets 0,\,\,u\gets 0,\,\,v\gets 0,\,\,u'\gets 0,\,\, v'\gets
    0,\,\,curr_{lcs}\gets 0,\,\,tmp_{thr}\gets 0,\,\,tmp_{beg}\gets 0$
    \State $start \gets \top,\,\,beg_{run}\gets \top,\,\,push_{zero}\gets
    \bot,\,\,push_{one}\gets \bot$
    \For {\textit{every} $k\in\left[0,\,\, height\right)$}
    \If{$k=0\land col[pref[k]]=1$}
    \State $start \gets \bot$
    \EndIf
    \If{$col[k]=0$}
    \State $c\gets c+1$
    \EndIf
    \EndFor
    \State $runs\gets[0..0]$
    \Comment sparse bitvector for runs of length $height+1$
    \State $thrs\gets[0..0]$
    \Comment sparse bitvector for thresholds of length $height$
    \State $zeros\gets[0..0]$
    \Comment sparse bitvector for zeros of length $c$
    \State $ones\gets[0..0]$
    \Comment sparse bitvector for ones of length $height-c$
    \State $samples_{beg} \gets [],\,\,samples_{end}\gets []$
    \Comment couple of vectors for samples of length $r$
    \If{$start$}
    \State $push_{one}\gets \top$
    \Else
    \State $push_{zero}\gets \top$
    \EndIf
    \For {\textit{every} $k\in\left[0,\,\, height\right)$}
    \If{$beg_{run}$}
    \State $u\gets u',\,\,v\gets v',\,\,tmp_{beg}\gets pref[k]$
    \State $beg_{run}\gets \bot$
    \EndIf
    \If{$col[pref[k]]=1$}
    \State $v'\gets v'+1$
    \Else
    \State $u'\gets u'+1$
    \EndIf
    \If{$k=0\lor col[pref[k]]\neq col[pref[k-1]]$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$div[k]<curr_{lcs}$}
    \State $curr_{lcs}\gets div[k],\,\,tmp_{thr}\gets k$
    \EndIf
    \If{$k=height-1\lor col[pref[k]]\neq col[pref[k+1]]$}
    \State $runs[k]\gets 1$
    \If{$k\neq height-1\land div[k+1]<div[tmp_{thr}]$}
    \State $thrs[k]\gets 1$
    \Else
    \State $thrs[tmp_{thr}]\gets 1$
    \EndIf
    \State $push(samples_{beg}, tmp_{beg})$
    \State $push(samples_{end}, pref[k])$
    \If{$push_{one}$}
    \If{$v\neq 0$}
    \State $ones[k-1]=1$
    \EndIf
    \State $swap(push_{zero},\,\,push_{one})$
    \Else
    \If{$u\neq 0$}
    \State $zeros[k-1]=1$
    \EndIf
    \State $swap(push_{zero},\,\,push_{one})$
    \EndIf
    \State $beg_{run}\gets \top$
    \EndIf
    \EndFor
    \If{$|zeros|\neq 0$}
    \State $zeros[|zeros|-1]\gets 1$
    \EndIf
    \If{$|ones|\neq 0$}
    \State $ones[|ones|-1]\gets 1$
    \EndIf
    \State \textit{build rank/select for the four bitvectors}
    \State \textbf{return}
    $(start,\,\,c,\,\,runs,\,\,zeros,\,\,ones,\,\,samples_{beg},\,\,samples_{end},\,\,div)$ 
    \EndFunction
  \end{algorithmic}
  \caption{{\footnotesize{Algoritmo per la costruzione di una colonna della RLPBWT con bitvectors}}}
\end{algorithm}
\begin{algorithm}[H]
  \footnotesize
  \begin{algorithmic}[1]
    \Function{get\_symbol}{$s, \,\,r$}
    \Comment $s=\top$ iff column start with 0, $r$ run index
    \If{$s$}
    \State \textbf{if} $r\bmod 2 = 0$ \textbf{then} \textbf{return} $0$
    \textbf{else} \textbf{return} $1$
    \Else
    \State \textbf{if} $r\bmod 2 = 0$ \textbf{then} \textbf{return} $1$
    \textbf{else} \textbf{return} $0$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per estrazione simbolo da una run in una colonna}
\end{algorithm}

\begin{algorithm}[H]
  \footnotesize
  \begin{algorithmic}[1]
    \Function{uvtrick}{$k,\,\, i$}
    \Comment $k$ is column index, $i$ row index
    \If{$i = 0$}
    \State \textbf{return} $(0,\,\,0)$
    \EndIf
    \State $run \gets rank_h^{k}(i)$
    \If{$run=0$}
    \If{$start^k$}
    \State \textbf{return} $(index,\,\, 0)$
    \Else
    \State \textbf{return} $(0, \,\,index)$
    \EndIf
    \ElsIf{$run=1$}
    \If{$start^k$}
    \State \textbf{return} $(select_h^{k}(run)+1,\,\, i-(select_h^{k}(run)+1))$
    \Else
    \State \textbf{return} $(i-(select_h^{k}(run)+1),\,\, select_h^{k}(run)+1)$
    \EndIf
    \Else
    \If{$run\bmod 2 = 0$}
    \State $pre_u\gets select_u^{k}(\frac{run}{2})+1$
    \State $pre_v\gets select_v^{k}(\frac{run}{2})+1$
    \State $offset \gets i -(select_h^{k}(run)+1)$
    \If{$start^k$}
    \State \textbf{return} $(pre_u+offset,\,\, pre_v)$
    \Else
    \State \textbf{return} $(pre_u, \,\,pre_v+offset)$
    \EndIf
    \Else
    \State $run_u\gets (\frac{run}{2})+1$
    \State $run_v\gets \frac{run}{2}$
    \If{$\neg start^k$}
    \State $swap(run_u, run_v)$
    \EndIf
    \State $pre_u\gets select_u^{k}(run_u)+1$
    \State $pre_v\gets select_v^{k}(run_v)+1$
    \State $offset \gets i -(select_h^{k}(run)+1)$
    \If{$start^k$}
    \State \textbf{return} $(pre_u, \,\,pre_v+offset)$
    \Else
    \State \textbf{return} $(pre_u+offset, \,\,pre_v)$
    \EndIf
    \EndIf
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per uvtrick}
\end{algorithm}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{lf}{$k,\,\, i, \,\,s$}
    \Comment $k$ is column index, $i$ row index, $s$ symbol
    \State $c\gets rlpbwt[k].c$
    \State $(u, v) \gets uvtrick(k,\,\,i)$
    \If{$s = 0$}
    \State \textbf{return} $u$
    \Else
    \State \textbf{return} $c+v$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per lf-mapping}
\end{algorithm}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \Function{reverse\_lf}{$k, \,\,i$}
    \Comment $k$ is column index, $i$ row index
    \If{$k=0$}
    \Comment by design
    \State \textbf{return} $0$
    \EndIf
    \State $k\gets k-1$
    \State $c\gets rlpbwt[k].c$
    \If{$i<c$}
    \If{$start^k$}
    \State $run\gets rank_u^{k}(i)\cdot 2$
    \Else
    \State $run\gets rank_u^{k}(i)\cdot 2+1$
    \EndIf
    \State $i_{run}\gets 0$
    \If{$run\neq 0$}
    \State $i_{run}\gets select_h^{k}(run)+1$
    \EndIf
    \State $(prev_0,\,\,\_)\gets uvtrick(k,\,\,i_{run})$
    \State \textbf{return} $i_{run}+(i-prev_0)$
    \Else
    \If{$start^k$}
    \State $run\gets rank_v^{k}(i)\cdot 2+1$
    \Else
    \State $run\gets rank_v^{k}(i)\cdot 2$
    \EndIf
    \State $i_{run}\gets 0$
    \If{$run\neq 0$}
    \State $i_{run}\gets select_h^{k}(run)+1$
    \EndIf
    \State $(\_,\,\,prev_1)\gets uvtrick(k,\,\,i_{run})$
    \State \textbf{return} $i_{run}+(i-(c+prev_1))$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per lf-mapping inverso}
\end{algorithm}

\begin{algorithm}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{external\_matches}{$z$}
    \Comment assuming $|z|=rlpbwt.width$
    \State $f\gets 0,\,\,f_{run}\gets 0,\,\,f'\gets 0$
    \State $g\gets 0,\,\,g_{run}\gets 0,\,\,g'\gets 0$
    \State $e\gets 0,\,\,l\gets 0$
    \For {\textit{every} $k\in\left[0,\,\, |z|\right)$}
    \State $f_{run}\gets rank_h^k(f),\,\,g_{run}\gets rank_h^k(g)$
    \State $f'\gets lf(k,\,\, f,\,\, z[k]),\,\,g'\gets lf(k,\,\, g,\,\, z[k])$
    \State $l\gets g-f$
    \If{$f'<g'$}
    \State $f\gets f',\,\,g\gets g'$
    \Else
    \If{$k\neq 0$}
    \State \textbf{report} \textit{matches in} $[e,\,\, k-1]$ \textit{with} $l$
    haplotypes   
    \EndIf
    \If{$f'=|lcp^{k+1}|$}
    \State $e\gets k+1$
    \Else
    \State $e\gets lcp^{k+1}[f']$
    \EndIf
    
    \If{$(z[e]=0\land f'>0)\lor f'=height$}
    \State $f'\gets g'-1$
    \If{$e\geq 1$}
    \State $f_{rev}\gets f',\,\,k'\gets k+1$
    \While {$k'\neq e-1$}
    \State $f_{rev}\gets reverse\_lf(k', \,\,f_{rev}),\,\,k'\gets k'-1$
    \EndWhile
    \State $run\gets rank_h^{k'}(f_{rev}),\,\,symb\gets get\_symbol(start^{k'},
    run)$ 
    \While {$e>0\land z[e-1]=symb$}
    \State $f_{rev}\gets reverse\_lf(e, \,\,f_{rev})$
    \State $run\gets rank_h^{e-1}(f_{rev})$
    \State $symb\gets get\_symbol(start^{e-1}, run)$
    \EndWhile
    \EndIf
    \State \textbf{while} $f'>0\land (k+1)-lcp^{k+1}[f]\leq e$ \textbf{do}
    $e\gets e-1$ 
    \State $f\gets f',\,\,g\gets g'$
    \Else
    \State $g'\gets f'-1$
    \If{$e\geq 1$}
    \State $f_{rev}\gets f',\,\,k'\gets k+1$
    \While {$k'\neq e-1$}
    \State $f_{rev}\gets reverse\_lf(k', \,\,f_{rev}),\,\,k'\gets k'-1$
    \EndWhile
    \State $run\gets rank_h^{k'}(f_{rev}),\,\,symb\gets get\_symbol(start^{k'},
    run)$ 
    \While {$e>0\land z[e-1]=symb$}
    \State $f_{rev}\gets reverse\_lf(e, \,\,f_{rev})$
    \State $run\gets rank_h^{e-1}(f_{rev})$
    \State $symb\gets get\_symbol(start^{e-1}, run)$
    \EndWhile
    \EndIf
    \State \textbf{while} $e<height\land (k+1)-lcp^{k+1}[e]\leq e$ \textbf{do}
    $e\gets e+1$  
    \State $f\gets f',\,\,g\gets g'$
    \EndIf
    \EndIf
    \EndFor
    \If{$f<g$}
    \State $l\gets g-f$
    \State \textbf{report} \textit{matches in} $[e,\,\, |z|-1]$ \textit{with} $l$
    haplotypes   
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per match con aplotipo esterno con panel $width\times
  height$} 
\end{algorithm}
\begin{algorithm}
  \scriptsize
  \begin{algorithmic}[1]
    \Function{matches\_ms}{$z$}
    \State $ms_{row}\gets [0..0],\,\,ms_{len}\gets [0..0]$
    \Comment ms vectors with row and len of length $|z|$
    \State $curr_{row}\gets
    rlpbwt[0].samples_{end}[|rlpbwt[0].samples_{end}|-1]$
    \State $curr_{index}\gets curr_{row}$
    \State $curr_{run}\gets rank_h^0(curr_{index})$
    \State $symb\gets get\_symbol(start^0, curr_{run})$
    \Comment \textbf{build matching statistics row}
    \For {\textit{every} $k\in[0, |z|)$}

    \If{$z[i]=symb$}
    \State $ms_{row}[k]\gets curr_{row}$
    \If{$k\neq |z|-1$}
     \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \Else
    \State $curr_{thr}\gets rank_t^k(curr_{index})$
    \State $force_{down} \gets \top$\textit{ iff we are over a threshold not at
    the end of a run}
     \State $force_{down} \gets \top$\textit{ iff we are over a threshold at
    the end of a run and DOWN function is $\top$}
    \If{$|samples_{beg}^k|=1$}
    \State $ms_{row}[k]\gets height$
    \If{$k\neq |z|-1$}
    \State $curr_{row}\gets
    rlpbwt[k+1].samples_{end}[|rlpbwt[k+1].samples_{end}|-1]$
    \State $curr_{index}\gets height-1$
    \State $curr_{run}\gets rank_h^{k+1}(curr_{index})$
    \State $symb\gets get\_symbol(start^{k+1}, curr_{run})$
    \EndIf
    \ElsIf{$(curr_{run}\neq 0 \land curr_{run}=curr_{thr}\land \neg down)\lor
    curr_{run}=|samples_{beg}^k|-1$} 
    \State $curr_{index}\gets select_h^{k}(curr_{run})$
    \State $curr_{row}\gets samples_{end}^k[curr_{run}-1]$
    \State $ms_{row}[k]\gets curr_{row}$
    \If{$k\neq |z|-1$}
     \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \Else
    \State $curr_{index}\gets select_h^{k}(curr_{run}+1)+1$
    \State $curr_{row}\gets samples_{beg}^k[curr_{run}+1]$
    \State $ms_{row}[k]\gets curr_{row}$
    \If{$k\neq |z|-1$}
     \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \EndIf
    
    \EndIf
    \EndFor
    \Comment \textbf{build matching statistics len}
    \For {\textit{every} $k\in[0,|ms_{row}|)$}
    \If{$ms_{row}[k] = height$}
    \State $ms_{len}[k]\gets 0$
    \Else
    \Comment $ra$ is a data structure for random access over the orginale panel
    \State $tmp_{index}\gets i,\,\,tmp_{len}\gets 0$
    \While {$tmp_{index}\geq 0 \land z[tmp_{index}]=ra(ms_{row}[k],
    tmp_{index})$}
   
    \State $tmp_{index}\gets tmp_{index}-1,\,\,tmp_{len}\gets tmp_{len}+1$
    \EndWhile
    \State $ms_{len}[k]\gets tmp_{len}$
    \EndIf
    \EndFor
    \For {\textit{every} $k\in[0,|ms_{row}|)$}
    \Comment \textbf{build matching statistics matches}
    \State \textit{report match at} $ms_{row}[k]$ \textit{with} $ms_{len}[k]$
    \textit{iff} $ms_{len}[k]> ms_{len}[k+1]$
    \State \textit{or} $ms_{len}[k]= ms_{len}[k+j]$, $j\geq 1$ and $\nexists j$
    \textit{such that}  $ms_{len}[k]< ms_{len}[k+j]$
    \EndFor
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per match con matching-statistics (MS) e thresholds}
\end{algorithm}
\begin{algorithm}
  \begin{algorithmic}
    \Function {down}{$pos, prev, next$}
    \State \textit{using LCE queries or random access check the longest common
    prefix between $pos$ and $prev$ and between $pos$ and $next$}
    \State \textit{if the latter is greater or equal return $\top$, else $\bot$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}
\begin{algorithm}
  \scriptsize
  \begin{algorithmic}[1]
    \Function{matches\_ms\_lce}{$z$}
    \State $ms_{row}\gets [0..0],\,\,ms_{len}\gets [0..0]$
    \Comment ms vectors with row and len of length $|z|$
    \State $curr_{row}\gets
    rlpbwt[0].samples_{end}[|rlpbwt[0].samples_{end}|-1]$
    \State $curr_{index}\gets curr_{row},\,\,curr_{run}\gets
    rank_h^0(curr_{index})$ 
    \State $symb\gets get\_symbol(start^0, curr_{run})$
    \Comment \textbf{build matching statistics row}
    \For {\textit{every} $k\in[0, |z|)$}
    \If{$z[i]=symb$}
    \State $ms_{row}[k]\gets curr_{row}$
    \If{$k=0$}
    \State $ms_{len}[k] \gets 1$
    \Else
    \State $ms_{len}[k] \gets ms_{len}[k-1]+1$
    \EndIf
    \If{$k\neq |z|-1$}
     \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \Else
    
    \If{$|samples_{beg}^k|=1$}
    \State $ms_{row}[k]\gets height$
    \State $ms_{len}[k]\gets 0$
    \If{$k\neq |z|-1$}
    \State $curr_{row}\gets
    rlpbwt[k+1].samples_{end}[|rlpbwt[k+1].samples_{end}|-1]$
    \State $curr_{index}\gets height-1$
    \State $curr_{run}\gets rank_h^{k+1}(curr_{index})$
    \State $symb\gets get\_symbol(start^{k+1}, curr_{run})$
    \EndIf
    \Else
    \If{$curr_{run}=|samples_{beg}^k|-1$}
    \State $curr_{index}\gets select_h^k(curr_{run}),\,\,prev_{row}\gets
    samples_{end}^k[curr_{run}-1]$ 
    \State $lce\gets LCE(k, curr_{row}, prev_{row})$
    \State $ms_{row}[k]\gets prev_{row},\,\,curr_{row}\gets prev_{row}$
    \If{$k=0$}
    \State $ms_{len}[k] \gets 1$
    \Else
    \State $ms_{len}[k] \gets min(ms_{len}[k-1], lce_{len})+1$
    \EndIf
    \If{$k\neq |z|-1$}
    \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$  
    \EndIf
    
    \ElsIf{$curr_{run}=0$}
    \State $curr_{index}\gets select_h^k(curr_{run}+1)+1,\,\,next_{row}\gets
    samples_{beg}^k[curr_{run}+1]$ 
    \State $lce\gets LCE(k, curr_{row}, next_{row})$
    \State $ms_{row}[k]\gets next_{row},\,\,curr_{row}\gets next_{row}$
    \If{$k=0$}
    \State $ms_{len}[k] \gets 1$
    \Else
    \State $ms_{len}[k] \gets min(ms_{len}[k-1], lce_{len})+1$
    \EndIf
  
    \If{$k\neq |z|-1$}
    \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \Else
    \State $prev_{row}\gets samples_{end}^k[curr_{run}-1],\,\,next_{row}\gets
    samples_{beg}^k[curr_{run}+1]$ 
    \State $lce\gets \max_{len} (LCE(k, curr_{row}, prev_{row}), LCE(k,
    curr_{row}, next_{row}))$
    \State $curr_{row}\gets lce_{row}$
    \State $ms_{row}[k]\gets curr_{row}$
    \If{$k=0$}
    \State $ms_{len}[k] \gets 1$
    \Else
    \State $ms_{len}[k] \gets min(ms_{len}[k-1], lce_{len})+1$
    \EndIf
    \If{$k\neq |z|-1$}
    \State $(curr_{index},\,\,curr_{run},\,\,symb)\gets UPDATE(k, curr_{index},
    z)$ 
    \EndIf
    \EndIf
    \EndIf
    \EndIf
    \EndFor
    
    \For{\textit{every} $k\in[0,|ms_{row}|)$}
    \Comment \textbf{build matching statistics matches}
    \State \textit{report match at} $ms_{row}[k]$ \textit{with} $ms_{len}[k]$
    \textit{iff} $ms_{len}[k]> ms_{len}[k+1]$
    \State \textit{or} $ms_{len}[k]= ms_{len}[k+j]$, $j\geq 1$ and $\nexists j$
    \textit{such that}  $ms_{len}[k]< ms_{len}[k+j]$
    \EndFor
    \EndFunction
    
  \end{algorithmic}
  \caption{Algoritmo per match con matching-statistics (MS) e LCE}
\end{algorithm}
\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{update}{$k, curr_{index}, z$}
    \State $curr_{index}\gets lf(k, curr_{index}, z[k])$
    \State $curr_{run}\gets rank_h^{k+1}(curr_{index})$
    \State $symb\gets get\_symbol(start^{k+1}, curr_{run})$
    \State \textbf{return} $(curr_{index},\,\,curr_{run},\,\,symb)$
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per l'update usando le matching statistics} 
\end{algorithm}
\begin{algorithm}
  \footnotesize
  \begin{algorithmic}[1]
    \Function{Build\_phi}{$cols, panel, prefix$}
    \Comment  $prefix$ is the last prefix array
    \State $\varphi\gets [[0..0]..[0..0]],\,\,\varphi^{-1}\gets
    [[0..0]..[0..0]]$ 
    \Comment sparse bit vector panels for $\varphi$ and $\varphi^{-1}$
    \State $\varphi_{supp} = [],\,\,\varphi_{supp}^{-1} = []$
    \Comment vectors for $\varphi$ and $\varphi^{-1}$ row values
    \For {\textit{every} $k\in [0,|cols|)$}
    \For {\textit{every} $i\in [0,|samples_{beg}|)$}
    \State $\varphi[sample_{beg}^{k}[i]][k]\gets 1$
    \If{$i=0$}
    \State $push(\varphi_{supp}[sample_{beg}^{k}[i]], panel_{height})$
    \Else
    \State $push(\varphi_{supp}[sample_{beg}^{k}[i]],sample_{end}^{k}[i-1])$
    \EndIf

    \State $\varphi^{-1}[sample_{end}^{k}[i]][k]\gets 1$
    \If{$i=|sample_{beg}^k|-1$}
    \State $push(\varphi_{supp}^{-1}[sample_{end}^{k}[i]], panel_{height})$
    \Else
    \State $push(\varphi_{supp}^{-1}[sample_{end}^{k}[i]],sample_{beg}^{k}[i+1])$
    \EndIf
    \EndFor
    \EndFor
    \For {\textit{every} $k\in [0,|prefix|)$}
    \If{$\varphi[k][|\varphi[k]|-1] = 0$}
    \State $\varphi[k][|\varphi[k]|-1]\gets 1$
    \If{$k=0$}
    \State $push(\varphi_{supp}[prefix^k], panel_{height})$
    \Else
    \State $push(\varphi_{supp}[prefix^k] ,prefix^k[i-1])$
    \EndIf
    \EndIf

    \If{$\varphi^{-1}[k][|\varphi[k]|-1] = 0$}
    \State $\varphi^{-1}[k][|\varphi[k]|-1]\gets 1$
    \If{$k=|prefix|-1$}
    \State $push(\varphi^{-1}_{supp}[prefix^k], panel_{height})$
    \Else
    \State $push(\varphi^{-1}_{supp}[prefix^k] ,prefix^k[i+1])$
    \EndIf
    \EndIf
    \EndFor
    \State \textit{build rank/select for every sparse bitvector in} $\varphi$
    and $\varphi^{-1}$
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per la costruzione della struttura per $\varphi$ e
  $\varphi^{-1}$} 
\end{algorithm}
\begin{algorithm}
  \begin{algorithmic}[1]
    \Function {$\varphi$}{$prefix_{value}, col$}
    \State $res\gets
    \varphi_{supp}^{prefix_{value}}[rank_{\varphi}^{prefix_{value}}(col)]$ 
    \If{$res = panel_{height}$}
    \State \textbf{return} $null$
    \Else
    \State \textbf{return} $res$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \begin{algorithmic}[1]
    \Function {$\varphi^{-1}$}{$prefix_{value}, col$}
     \State $res\gets \varphi^{-1}_{supp}\,^{prefix_{value}}[rank_{\varphi^{-1}}^{prefix_{value}}(col)]$
    \If{$res = panel_{height}$ }
    \State \textbf{return} $null$
    \Else
    \State \textbf{return} $res$
    \EndIf
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmi per le query a $\varphi$ e $\varphi^{-1}$}
\end{algorithm}
\begin{algorithm}
  \begin{algorithmic}[1]
    \Function{extend\_matches}{$col, row, len$}
    \State $check_{down}\gets \top,\,\,check_{up}\gets \top$
    \While {$check_{down}$}
    \State $down_{row}\gets \varphi^{-1}(row, col)$
    \If{$lce\_bounded(col, row, down_{row}, len)$}
    \State $push(haplos, down_{row})$
    \State $row \gets down_{row}$
    \Else
    \State $check_{down}\gets \bot$
    \EndIf
    \EndWhile
    \While {$up_{down}$}
    \State $up_{row}\gets \varphi(row, col)$
    \If{$lce\_bounded(col, row, up_{row}, len)$}
    \State $push(haplos, up_{row})$
    \State $row \gets up_{row}$
    \Else
    \State $check_{up}\gets \bot$
    \EndIf
    \EndWhile
    \State \textbf{return} $haplos$
    \EndFunction
  \end{algorithmic}
  \caption{Algoritmo per estendere un match in $col$ usando $\varphi$,
  $\varphi^{-1}$ e MS} 
\end{algorithm}
\end{document}

% LocalWords:  divergence prefix